package com.yzy.hard;

/**
 * @Author 杨泽宇
 * @PackageName LeetCode
 * @Package com.yzy.hard
 * @Date 2023/12/26 00:39
 * @Description
 * 给你一个 m * n 的矩阵 seats 表示教室中的座位分布。如果座位是坏的（不可用），就用 '#' 表示；否则，用 '.' 表示。
 *
 * 学生可以看到左侧、右侧、左上、右上这四个方向上紧邻他的学生的答卷，但是看不到直接坐在他前面或者后面的学生的答卷。请你计算并返回该考场可以容纳的同时参加考试且无法作弊的 最大 学生人数。
 *
 * 学生必须坐在状况良好的座位上。
 *
 *
 *
 * 示例 1：
 *
 *
 *
 * 输入：seats = [["#",".","#","#",".","#"],
 *               [".","#","#","#","#","."],
 *               ["#",".","#","#",".","#"]]
 * 输出：4
 * 解释：教师可以让 4 个学生坐在可用的座位上，这样他们就无法在考试中作弊。
 * 示例 2：
 *
 * 输入：seats = [[".","#"],
 *               ["#","#"],
 *               ["#","."],
 *               ["#","#"],
 *               [".","#"]]
 * 输出：3
 * 解释：让所有学生坐在可用的座位上。
 * 示例 3：
 *
 * 输入：seats = [["#",".",".",".","#"],
 *               [".","#",".","#","."],
 *               [".",".","#",".","."],
 *               [".","#",".","#","."],
 *               ["#",".",".",".","#"]]
 * 输出：10
 * 解释：让学生坐在第 1、3 和 5 列的可用座位上。
 * @Version 1.0
 */
public class maximumstudentstakingexam {
    public int maxStudents(char[][] seats) {
        int m = seats.length;
        int n = seats[0].length;
        int mask = 1 << n;
        // dp[i][j] 表示第 j 排（下标从 1 开始）的座位分配位掩码为 i 时的最大学生数
        int[][] dp = new int[mask][m + 1];
        int res = 0;
        // 模拟从第一排向第 m 排分配座位的过程
        for (int i = 1; i <= m; i++) {
            // invalid 记录当前行的破坏座位情况
            int invalid = 0;
            for (int j = 0; j < n; j++)
                if (seats[i - 1][j] == '#')
                    invalid |= 1 << j;
            // 枚举当前行的分配情况
            for (int k = 0; k < mask; k++) {
                // 两种情况导致分配不合法：1、分配在了坏的座位上：k & invalid 的某一位不是 0；2、分配出现了相邻的情况（比较同行只需要枚举 k & (k << 1) 即可，因为整数范围大于 n 位，k & (k << 1) 包含了 k && (k >>> 1) 的信息）
                if ((k & invalid) != 0 || (k & (k << 1)) != 0) {
                    // 将当前状态标记为 -1，代表状态不合法
                    dp[k][i] = -1;
                    continue;
                }
                // 再枚举前一排的情况
                for (int s = 0; s < mask; s++) {
                    // 三种情况导致分配不合法：1、状态 s 不合法，dp[s][i - 1] 已经被标记为 -1；2、右前方有人：k & (s >>> 1) != 0；3、左前方有人：k & (s << 1) != 0
                    if (dp[s][i - 1] == -1 || (k & (s << 1)) != 0 || (k & (s >>> 1)) != 0)
                        continue;
                    // 递推 dp[k][i]，并更新最大值
                    dp[k][i] = Math.max(dp[k][i], dp[s][i - 1] + Integer.bitCount(k));
                    res = Math.max(res, dp[k][i]);
                }
            }
        }
        return res;
    }
}