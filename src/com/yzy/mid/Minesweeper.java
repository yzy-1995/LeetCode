package com.yzy.mid;

/**
 * @Author 杨泽宇
 * @PackageName LeetCode
 * @Package com.yzy.mid
 * @Date 2023/08/05 00:02
 * @Description
 * 让我们一起来玩扫雷游戏！
 *
 * 给你一个大小为 m x n 二维字符矩阵 board ，表示扫雷游戏的盘面，其中：
 *
 * 'M' 代表一个 未挖出的 地雷，
 * 'E' 代表一个 未挖出的 空方块，
 * 'B' 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的 已挖出的 空白方块，
 * 数字（'1' 到 '8'）表示有多少地雷与这块 已挖出的 方块相邻，
 * 'X' 则表示一个 已挖出的 地雷。
 * 给你一个整数数组 click ，其中 click = [clickr, clickc] 表示在所有 未挖出的 方块（'M' 或者 'E'）中的下一个点击位置（clickr 是行下标，clickc 是列下标）。
 *
 * 根据以下规则，返回相应位置被点击后对应的盘面：
 *
 * 如果一个地雷（'M'）被挖出，游戏就结束了- 把它改为 'X' 。
 * 如果一个 没有相邻地雷 的空方块（'E'）被挖出，修改它为（'B'），并且所有和其相邻的 未挖出 方块都应该被递归地揭露。
 * 如果一个 至少与一个地雷相邻 的空方块（'E'）被挖出，修改它为数字（'1' 到 '8' ），表示相邻地雷的数量。
 * 如果在此次点击中，若无更多方块可被揭露，则返回盘面。
 *
 *
 * 示例 1：
 *
 *
 * 输入：board = [["E","E","E","E","E"],["E","E","M","E","E"],["E","E","E","E","E"],["E","E","E","E","E"]], click = [3,0]
 * 输出：[["B","1","E","1","B"],["B","1","M","1","B"],["B","1","1","1","B"],["B","B","B","B","B"]]
 * 示例 2：
 *
 *
 * 输入：board = [["B","1","E","1","B"],["B","1","M","1","B"],["B","1","1","1","B"],["B","B","B","B","B"]], click = [1,2]
 * 输出：[["B","1","E","1","B"],["B","1","X","1","B"],["B","1","1","1","B"],["B","B","B","B","B"]]
 * @Version 1.0
 */
public class Minesweeper {
    char[][] b;
    int m, n;
    int[][] dir = {{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1}};
    public char[][] updateBoard(char[][] b, int[] c) {
        this.b = b;
        this.m = b.length; this.n = b[0].length;
        // 由于后续只拓展B或E点，所以踩到地雷的情况只存在于第一步，最开始判断M即可。
        if(b[c[0]][c[1]] == 'M'){
            b[c[0]][c[1]] = 'X';
            return b;
        }
        // 从给定点扩散探索。
        dfs(c[0], c[1]);
        return b;
    }
    // 搜索(i,j)所有相邻点，根据是否存在地雷修改该点值，若不与地雷相邻则再次扩散探索相邻点。
    public void dfs(int i, int j){
        // 第一遍搜索当前点周围地雷数量cnt。
        int cnt = 0;
        for(int k = 0; k < 8; ++k){
            int row = i + dir[k][0], col = j + dir[k][1];
            if(row >= 0 && row < m && col >= 0 && col < n && b[row][col] == 'M')
                ++cnt;
        }
        // 若存在地雷则将当前点修改为cnt值后停止这一层，
        // 若无地雷则当前点修改为B，并第二次扩散探索所有相邻点。
        if(cnt > 0){
            b[i][j] = (char)('0' + cnt);
        }else{
            b[i][j] = 'B';
            for(int k = 0; k < 8; ++k){
                int row = i + dir[k][0], col = j + dir[k][1];
                if(row >= 0 && row < m && col >= 0 && col < n && b[row][col] == 'E')
                    dfs(row, col);
            }
        }
    }
}